---
title: "Single Site, Single Disturbance, MultiPool"
author: "Mike Dietze"
date: "10/19/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(BayesianTools)
library(magrittr)
set.seed(42)
```

## Todo

-   Tweak model to have a simple C budget -- where does the C go when the model doesn't assimilate disturbance?

## helper functions

```{r}
source("multi.ens.adj.R")

tobit <- function(x){
  x[x < 0] <- 0
  x
}

disturbance <- function(x){ ## x = Bleaf, Bsoil, Bstem
  old.biomass <- x[c(1,3)]
  new.biomass <- tobit(mvtnorm::rmvnorm(1,mu0,V0)) ## draw disturbed leaf and stem
  check.max <- which(new.biomass > old.biomass)
  if(length(check.max)>0) new.biomass[check.max] = old.biomass[check.max]
  residual = sum(old.biomass-new.biomass)
  x[c(1,3)] <- new.biomass
  x[2] <- x[2] + residual*alloc.soil
  removal <- residual*(1-alloc.soil)
  return(x)
}

```

## drivers

```{r}
NT = 25
nt = 365*NT
time = 1:nt
nd   = 31 ## number of driver ensembles
PAR <- matrix(NA,nd,nt)
for(i in 1:nd){
  PAR[i,] <- VSEMcreatePAR(time)  
}
plot(PAR[1,], main = "PAR (driving the model)", xlab = "Day",cex=0.35)
```

## Parameters

```{r}
refPars <- VSEMgetDefaults()
refPars$lower[9:11] = 1
np = 50
sigmaP = diag((refPars$upper - refPars$lower)/10)^2 ## assume range is +/- 5 SD
Theta <- as.data.frame(mvtnorm::rmvnorm(np,refPars$best,sigmaP))
colnames(Theta) <- rownames(refPars)
par(mfrow=c(3,4))
for(i in 1:11){
  Theta[Theta[,i] < refPars$lower[i] , i] <- refPars$lower[i]
  Theta[Theta[,i] > refPars$upper[i] , i] <- refPars$upper[i]
  hist(Theta[,i],main=colnames(Theta)[i])
}
```

## initial conditions

```{r}
## spin up
ne = 200
met = sample.int(nd,ne,replace=TRUE)
par = sample.int(np,ne,replace=TRUE)
Na <- matrix(NA,ne,3)
for(i in 1:ne){
  Na[i,] = VSEM(as.numeric(Theta[par[i],]),PAR = PAR[met[i],])[nt,2:4]
}
Na.orig = Na
Nmu = NmuK = NfK = Nf = Na*NA
par(mfrow=c(1,3))
hist(Na[,1],main="Cleaf")
hist(Na[,2],main="Csoil")
hist(Na[,3],main="Cstem")
```

## set up storage and parameters

```{r}
## hard coded 
Q = diag(c(0.1,0.1,0.1)) ## process error
R = diag(c(.25,10,1))      ## observation error
THETA <- as.matrix(Theta[par,]) ## ensemble parameters
mu0 <- c(1,1)            ## mean leaf & stem biomass after disturbance
V0  <- diag(c(0.15,0.25))^2## var in post disturbance leaf and stem biomass
alloc.soil = 0.25        ## fraction of removed C that goes in the soil
p.dist = 0.05

## storage
Dbar = 0
Analysis <- Forecast <- list()
Forecast.KD = Analysis.KD = list() ## EnKF with Disturbance
removal = matrix(0,ne,NT)

## pseudodata
No = matrix(NA,NT,3)                   ## storage for observed state
Ntrue = matrix(NA,NT,3)                ## storage for latent "true" state
true = 42                              ## reference ensemble member
D.true = rep(0,NT)                     ## true disturbance timeseries
D.true[10] = 1                         ## prescribe a disturbance
refpar = as.numeric(Theta[par[true],]) ## grab the "true" parameters
refpar[9:11] = Na[true,]               ## set initial biomass pools
for(t in 1:NT){
  tsel <- (t-1)*365 + 1:365            ## select 1 yr of met  
  ref.mu = VSEM(refpar,PAR[met[true],tsel])[365,2:4]    ## forward simulation
  ref.f  = mvtnorm::rmvnorm(1,ref.mu,Q)## process error
  if(D.true[t]){
    ref.f = disturbance(ref.f)
  }
  ref.f = tobit(ref.f)
  refpar[9:11] = ref.f                 ## update IC for next iteration
  Ntrue[t,] = ref.f
  No[t,] = tobit(mvtnorm::rmvnorm(1,ref.f,R)) ## observation error
}
par(mfrow=c(3,1))
plot(No[,1])
plot(No[,2])
plot(No[,3])
```

```{r,echo=FALSE,results='hide',message=FALSE}
AnalysisSSSDMP <- "  ## SingleSite SingleDisturbance MultiPool
model{
  ## prior
  muN ~ dmnorm(mufN,pfN)                ## forecast prior on Not disturbed
  muD ~ dmnorm(mufD,pfD)                ## forecast prior on Disturbed
  D ~ dbern(p)                          ## disturbance probability
  ## Analysis 
  n <- D*muD + (1-D)*muN                ## select between disturbed and undisturbed
  Y ~ dmnorm(n,R)                       ## Observation error
}"

Na <- NaK <- Na.orig
THETAK <- THETA
for(t in 1:NT){
  
  tsel <- (t-1)*365 + 1:365               ## Select days from driver files
  
  ## update IC
  THETA[,9:11]  <- Na    ## Multinomial
  THETAK[,9:11] <- NaK  ## EnKF w/ disturbance
  
  ## Forecast 
  for(i in 1:ne){
    fx       = VSEM(THETA[i,], PAR = PAR[met[i],tsel]) ## deterministic simulation
    Nmu[i,]  =  fx[365,2:4]                         ## state variables at time of assim
    fxK      = VSEM(THETAK[i,],PAR = PAR[met[i],tsel]) ## deterministic simulation
    NmuK[i,] = fxK[365,2:4] ## deterministic simulation
    epsilon  = mvtnorm::rmvnorm(1,rep(0,3),Q)                   ## process error  ** shared between versions **
    Nf[i,]   = Nmu[i,]  + epsilon
    NfK[i,]  = NmuK[i,] + epsilon
  }
  
  ## Disturbance
  d.prior <- rbinom(ne,1,p.dist)             ## prior on disturbance status
  sel <- !as.logical(d.prior)                ## select undisturbed ensemble members
  if(sum(!sel)>2){
    sel.dist = which(!sel)
    for(j in sel.dist){                      ## run disturbance model
      Nf[j,]  = disturbance(Nf[j,])
      NfK[j,] = disturbance(NfK[j,])
    }
    mufD  = colMeans(Nf[!sel,])
    pfD = solve(diag(c(0.15,0.5,0.25)^2)) #try(solve(var(Nf[!sel,])))
  } 
  if(sum(!sel) <= 2 || class(pfD) == "try-error") {   ## backup values if the ensemble stats fail
      mufD = c(mu0[1], mean(Nf[,2]),  mu0[2])            
      pfD  = solve(diag(c(0.15,0.5,0.25)^2))
  }
  Nf <- tobit(Nf)
  
  ## EnKF forecast stats
  NfK <- tobit(NfK)
  mufK = colMeans(NfK)
  PfK  = var(NfK)
  pfK  = solve(PfK)             ## Not disturbed forecast precision
  Forecast.KD[[t]] <- list(d.prior=d.prior,Nf=NfK,muf=mufK,pf=pfK)

  ## priors
  priors <- list(p    = mean(d.prior),         ## disturbance rate
                 mufN = colMeans(Nf[sel,]),    ## Not disturbed forecast means
                 mufD = mufD,   ## Disturbed forecast means
                 pfN  = solve(var(Nf[sel,])),  ## Not disturbed forecast precision
                 pfD  = pfD  ## Disturbed forecast precision
  )
  Forecast[[t]] <- c(list(d.prior=d.prior,Nf=Nf),priors)
  
  ## Analysis
  update = c(list(Y=No[t,],R=solve(R)),priors)
  mod <- rjags::jags.model(file=textConnection(AnalysisSSSDMP),
                           data=update,
                           n.adapt=1000,n.chains=3)
  jdat <- rjags::coda.samples(mod,variable.names=c("n","D","muN","muD"),n.iter=10000) 
  
  ## update parameters & save Analysis posterior
  dat = as.matrix(jdat)
  nsel <- grep(pattern="^n",x=colnames(dat))
  
  ## draw new IC
  Na <- multi.ens.adj(
          Xf   = Nf,
          cf   = d.prior,
          mu.f = rbind(priors$mufN,priors$mufD),
          Pf   = abind::abind(solve(priors$pfN),
                 solve(priors$pfD),
                 along=3),
          Xa = dat[,nsel],
          ca = dat[,"D"])
  Ca <- Na[,1] ## updated class assignments
  Na <- tobit(Na[,-1])
#  sel.ic <- sample.int(nrow(dat), ne, replace=TRUE)
#  Na <- dat[sel.ic,nsel]
  Analysis[[t]] <- list(MCMC=dat,
                        Na = Na,
                        Ca = Ca)

  
  ## EnKF Analysis
  I = H <- diag(rep(1,3))
  K <- PfK %*% t(H) %*% solve(H%*%PfK%*%t(H) + R)
  muaK <- mufK + K%*%(No[t,] - mufK) 
  PaK <- (I-K %*% H)%*%PfK    
  paK = solve(PaK)
  NaK <- PEcAn.assim.sequential::adj.ens(Pf = PfK,X = NfK,mu.f = mufK,mu.a = muaK,Pa = PaK) %>% as.matrix()
  Analysis.KD[[t]] <- list(mua=muaK,pa=paK,Pa=PaK,Na=NaK)
  
}

```

```{r}
save(Forecast,Analysis,No,Ntrue,R,file="exp3.RData")
```

### time series

```{r}
pool.names=c("Cleaf","Csoil","Cstem")
for(i in 1:3){
  
  CI.Na = sapply(X = Analysis,function(y){
    x = y$MCMC
    sel.n = which(colnames(x) == paste0("n[",i,"]"))
    quantile(x[,sel.n],c(0.025,0.5,0.975))
  })
  #CI.Na = sapply(X = Analysis,function(x){
  #  apply(x,2,quantile,c(0.025,0.975))
  #})
  
  plot(No[,i],
       #ylim = range(rbind(CIN,data$Y)),xlim=xlim,type='n',
       ylab=pool.names[i],xlab="time")
  ecoforecastR::ciEnvelope(1:ncol(CI.Na),CI.Na[1,],CI.Na[3,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
  lines(CI.Na[2,],col="#b2df8a",lwd=2)
  lines(Ntrue[,i],lty=2,lwd=2)
}
```
### Ensemble adj at time of disturbance

```{r,fig.asp=1,fig.width=3}
#par(mfrow=c(1,3))

plot(Analysis[[10]]$Na[,1],Analysis[[10]]$Na[,3],pch="+",col=ecoforecastR::col.alpha("red",alpha=0.5),
     ylim=range(Forecast[[10]]$Nf[,3]),
     xlim=range(Forecast[[10]]$Nf[,1]),
     xlab=pool.names[1],ylab=pool.names[3],
     cex.lab=1.25,asp = 1)
points(Forecast[[10]]$Nf[,1],Forecast[[10]]$Nf[,3],cex=0.5)
points(No[10,1],No[10,3],cex=3,col=ecoforecastR::col.alpha("purple",alpha = 0.75),pch=18)

## ensemble adjustment
sel.a=sample.int(ne,10)
arrows(Forecast[[10]]$Nf[sel.a,1],Forecast[[10]]$Nf[sel.a,3],
       Analysis[[10]]$Na[sel.a,1],Analysis[[10]]$Na[sel.a,3],length = 0.1,lwd = 0.5)   
legend("topleft",
       legend=c("Forecast","Analysis","Data"),
       pch=c(1,3,18),col=c(1,2,"purple"),
       cex = 1.5)

```
## EnKF, no disturbance

```{r,echo=FALSE}
Na = Na.orig
Forecast.EnKF = Analysis.EnKF = list()
for(t in 1:NT){
  
  tsel <- (t-1)*365 + 1:365               ## Select days from driver files
  
  ## update IC
  THETA[,9:11] <- Na
  
  ## Forecast 
  for(i in 1:ne){
    Nmu[i,] = VSEM(THETA[i,],PAR = PAR[met[i],tsel])[365,2:4] ## deterministic simulation
    Nf[i,]  = mvtnorm::rmvnorm(1,Nmu[i,],Q) ## process error
  }
  
  muf = colMeans(Nf)    ## Not disturbed forecast means
  Pf  = var(Nf)
  pf  = solve(Pf)             ## Not disturbed forecast precision
  Forecast.EnKF[[t]] <- list(d.prior=d.prior,Nf=Nf,muf=muf,pf=pf)
  
  ## Analysis
  I = H <- diag(rep(1,3))
  K <- Pf %*% t(H) %*% solve(H%*%Pf%*%t(H) + R)
  mua <- muf + K%*%(No[t,] - muf) 
  Pa <- (I-K %*% H)%*%Pf    
  pa = solve(Pa)
  
  ## draw new IC
  #  Na <- mvtnorm::rmvnorm(ne,mua,Pa)
  Na <- PEcAn.assim.sequential::adj.ens(
    Pf = Pf,X = Nf,mu.f = muf,mu.a = mua,Pa = Pa)
  
  ## save Analysis posterior
  Analysis.EnKF[[t]] <- list(mua=mua,pa=pa,Pa=Pa,Na=Na)

}

```
