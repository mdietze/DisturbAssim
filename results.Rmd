---
output:
  pdf_document: default
  html_document: default
---
# Results

## Simulated data experiments

Overall, the results from the simulated data experiments (Table \@ref(tab:pseudoTable)) demonstrate that the proposed multinomial ensemble filter is able to successfully detect disturbances under a range of different conditions. 

Experiment 1, which aimed to capture a single disturbance at a single site for a single pool, was already depicted in Figure \@ref(fig:enkf) and Figure \@ref(fig:concept) when discussing the challenges facing traditional Kalman Filter variants. Specifically, Figure \@ref(fig:enkf) shows that the multinomial filter (blue) is able to capture the discrete nature of the disturbance at time 10, with the posterior probability of disturbance jumping from near zero before this event to 0.977 for the disturbance, and then dropping back down to near zero in subsequent years. Figure \@ref(fig:concept) bottom illustrates what is occurring in this disturbance year. As in the prior 9 years the forecast itself is multimodal, with most of the ensemble members predicting no disturbance and a small number predicting a disturbance event. The multinomial filter assigns a prior mean and variance to each mode based on the ensemble summary statistics, which is the same as a traditional EnKF except for the stratification by disturbance type, and then assigns each state a prior probability based on the ensemble frequency of being in each state (disturbed = dark red, undisturbed = green). When the observed data (red) suggests a large drop in LAI, the posterior (blue) not only updates the ensemble mean and variance of each mode, but also the probability of being in each mode. This posterior is still multimodal, but in this specific instance the weight assigned the undisturbed mode (0.023) is too low to be visually notable. Noteworthy is that the LAI in years 12 and 15 is actually lower than that in the disturbance year, yet the model still assigns this as being undisturbed. This occurs because in these years the observed low LAI is compatible with the observation error around the undisturbed forecast, which has a higher prior probability than the odds of subsequent disturbance.

Experiment 2 expands the assimilation to a multivariate forecast, in this case including joint predictions for leaf, wood, and soil carbon, and with a disturbance to both the leaf and wood pools (Figure \@ref(fig:sssd)). Figure \@ref(fig:sssdBi) shows the multivariate nature of the detection of the disturbance event at time 10, with the bimodal forecast ensemble shown in purple (undisturbed in the top right, disturbed in the bottom left), an observation in black that is consistent with the disturbed state, and the posterior ensemble in green. Arrows depict the adjustment of a random subset of individual ensemble members from the forecast prior to the analysis posterior.

```{r sssd, echo=FALSE,fig.asp=1.25,fig.cap="Experiment 2: Assimilation using process-based VSEM captures multi-pool disturbance to leaf and wood biomass"}

m = matrix(1:3,nrow=3,byrow = TRUE)
layout(m)

load("exp2.Rdata") # Generated by SingleSite_SingleDisturb_MultiPool.Rmd
#Figures showing all 3 pools cov, C accounting / attribution 
pool.names=c("Leaf","Soil","Wood")
scaled = c(1,10,1)
for(i in 1:3){
  
  CI.Na = sapply(X = Analysis,function(y){
    x = y$MCMC
    sel.n = which(colnames(x) == paste0("n[",i,"]"))
    quantile(x[,sel.n],c(0.025,0.5,0.975))
  })
  D.Na = sapply(X = Analysis,function(y){
    x = y$MCMC
    sel.n = which(colnames(x) == paste0("D"))
    mean(x[,sel.n])
  })
  CI.Na = CI.Na/scaled[i]
  
  rng = range(CI.Na)
  if(rng[1]<1) rng[1] = 0
  plot(No[,i]/scaled[i],
       ylim = rng,type='n',
       ylab=bquote(.(pool.names[i]) ~ (kgC/m^2)),xlab="time")
  ecoforecastR::ciEnvelope(1:ncol(CI.Na),CI.Na[1,],CI.Na[3,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
  lines(CI.Na[2,],col="#b2df8a",lwd=2)
  points(No[,i]/scaled[i])
  #lines(Ntrue[,i],lty=2,lwd=2)
  #lines(D.Na,lwd=2)
  if(i==1){
    legend("bottomright",legend=c("Assimilation","pseudodata"),
       lwd=5,col=c("#b2df8a","black"))
  }
}
```

```{r sssdBi,echo=FALSE, fig.asp=1,fig.width=6, fig.cap="Experiment 2: Forecast and Analysis ensembles at the disturbance (t=10). Arrows demonstrate the ensemble adjustment of a sample of 10 ensemble members."}
## for html set fig.width=3
load("exp2.Rdata")

plot(Analysis[[10]]$Na[,1],Analysis[[10]]$Na[,3],pch="+",col=ecoforecastR::col.alpha("#b2df8a",alpha=1),
     ylim=range(Forecast[[10]]$Nf[,3]),
     xlim=range(Forecast[[10]]$Nf[,1]),
     xlab=bquote(.(pool.names[1]) ~ (kgC/m^2)),ylab=bquote(.(pool.names[3])~(kgC/m^2)),
     cex.lab=1.25,asp = 1)
.(labNames[1]) ~ x^2
points(Forecast[[10]]$Nf[,1],Forecast[[10]]$Nf[,3],cex=1,col="purple",pch=18)
points(No[10,1],No[10,3],cex=3,col=1)
lines(No[10,1]+c(-1,1)*sqrt(R[1,1]),rep(No[10,3],2))
lines(rep(No[10,1],2),No[10,3]+c(-1,1)*sqrt(R[3,3]))

## ensemble adjustment
ne = nrow(Forecast[[10]]$Nf)
sel.a= seq(1,ne,length=10)#sample.int(ne,10)
arrows(Forecast[[10]]$Nf[sel.a,1],Forecast[[10]]$Nf[sel.a,3],
       Analysis[[10]]$Na[sel.a,1],Analysis[[10]]$Na[sel.a,3],length = 0.1,lwd = 0.5)   
legend("topleft",
       legend=c("Forecast","Analysis","Data"),
       pch=c(1,3,18),col=c("purple","#b2df8a",1),
       cex = 1.5)
```

** TODO: in bivariate plots, data is hard to see **

Experiment 3 (Figure \@ref(fig:multiPseudo) top row) illustrates the ability of the multinomial model to select between more than one disturbance. In the bivariate plot (top right panel) we can see that the model can successfully distinguishing between two types of disturbance, one that involves the loss of both wood and leaf biomass (e.g. fire, logging) and the other that just removes leaf biomass (e.g. defoliating forest pest). Experiment 4 (Figure \@ref(fig:multiPseudo) middle row) is similar to 3 but extends the woody biomass removing disturbance to one that causes a switch in PFT from a forest to a low-stature vegetation type (e.g. grassland, shrubland, agriculture), demonstrating that the model can handle land use and land cover changes. Finally, experiment 5 (Figure \@ref(fig:multiPseudo) bottom row) illustrates the extension of the assimilation to multiple sites, one that experiences a disturbance and one that does not. In the years prior to the disturbance the multivariate nature of the assimilation allows us to borrow strength across sites, with observations at one site reducing uncertainty not just at that site but at the other site as well based on the cross-site forecast covariance. That said,this example illustrates the ability of the multinomial model to avoid the impact of spurious correlations across sites during disturbance events. The presence of the disturbance at site 1 did not cause a reduction in biomass in site 2 during the disturbance, nor did it increase the productivity in site 2 in the years post-disturbance despite the large increase observed at site 1.
  
```{r multiPseudo, echo=FALSE, message = FALSE, fig.cap="Simulated experiments 3-5: Left hand column shows time series for the wood pool for all three experiments; Right hand shows bivariate ensemble adjustment at time of disturbance",fig.asp=1.25}

## figure with 3 rows, 2 col showing time series in rt and bivariate in left
#par(mfrow=c(3,2))
m = matrix(c(1,1,2,3,3,4,5,5,6),nrow=3,byrow = TRUE)
layout(m)

########experiment 3 - two disturb
load("exp3.Rdata") ## Generated by SingleSite_MultiDisturb_MultiPool.Rmd
pool.names=c("Leaf","Soil","Wood")
i = 3
CI.Na = sapply(X = Analysis,function(y){
  x = y$MCMC
  sel.n = which(colnames(x) == paste0("X[",i,"]"))
  quantile(x[,sel.n],c(0.025,0.5,0.975))
})
rng = range(CI.Na)
if(rng[1]<1) rng[1] = 0
plot(No[,i],
     ylim = rng,type='n',
     ylab=bquote(.(pool.names[i]) ~ (kgC/m^2)),xlab="time",
     main="Multi-Disturbance")
ecoforecastR::ciEnvelope(1:ncol(CI.Na),CI.Na[1,],CI.Na[3,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
lines(CI.Na[2,],col="#b2df8a",lwd=2)
points(No[,i])
legend("bottomleft",legend=c("Assimilation","pseudodata"),
       lwd=5,col=c("#b2df8a","black"))

plot(Analysis[[10]]$Na[,1],Analysis[[10]]$Na[,3],pch=Analysis[[10]]$Ca,col=ecoforecastR::col.alpha("#b2df8a",alpha=1),
     ylim=range(Forecast[[10]]$Nf[,3]),
     xlim=range(Forecast[[10]]$Nf[,1]),
     xlab=bquote(.(pool.names[1]) ~ (kgC/m^2)),ylab=bquote(.(pool.names[3]) ~ (kgC/m^2)),
     cex.lab=1.25,asp = 1)
points(Forecast[[10]]$Nf[,1],Forecast[[10]]$Nf[,3],cex=1,col="purple",pch=18)
points(No[10,1],No[10,3],cex=3,col=1)
lines(No[10,1]+c(-1,1)*sqrt(R[1,1]),rep(No[10,3],2))
lines(rep(No[10,1],2),No[10,3]+c(-1,1)*sqrt(R[3,3]))

## ensemble adjustment
ne = nrow(Forecast[[10]]$Nf)
sel.a= seq(1,ne,length=10)#sample.int(ne,10)
arrows(Forecast[[10]]$Nf[sel.a,1],Forecast[[10]]$Nf[sel.a,3],
       Analysis[[10]]$Na[sel.a,1],Analysis[[10]]$Na[sel.a,3],length = 0.1,lwd = 0.5)   
legend("bottomright",
       legend=c("Forecast","Analysis","Data"),
       pch=c(1,3,18),col=c("purple","#b2df8a",1),
       cex = 1.25)

##### experiment 4 - two disturb, pft switch
load("exp4.Rdata") ## SingleSite_MultiDisturb_MultiPool_MultiPFT.Rmd
pool.names=c("Leaf","Soil","Wood")
i = 3
CI.Na = sapply(X = Analysis,function(y){
  x = y$MCMC
  sel.n = which(colnames(x) == paste0("X[",i,"]"))
  quantile(x[,sel.n],c(0.025,0.5,0.975))
})
rng = range(CI.Na)
if(rng[1]<1) rng[1] = 0
plot(No[,i],
     ylim = rng,type='n',
     ylab=bquote(.(pool.names[i]) ~ (kgC/m^2)),xlab="time",
     main="Multi-Disturbance, PFT switching")
ecoforecastR::ciEnvelope(1:ncol(CI.Na),CI.Na[1,],CI.Na[3,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
lines(CI.Na[2,],col="#b2df8a",lwd=2)
points(No[,i])
legend("bottomleft",legend=c("Assimilation","pseudodata"),
       lwd=5,col=c("#b2df8a","black"))

plot(Analysis[[10]]$Na[,1],Analysis[[10]]$Na[,3],pch=Analysis[[10]]$Ca,col=ecoforecastR::col.alpha("#b2df8a",alpha=1),
     ylim=range(Forecast[[10]]$Nf[,3]),
     xlim=range(Forecast[[10]]$Nf[,1]),
     xlab=bquote(.(pool.names[1]) ~ (kgC/m^2)),
     ylab=bquote(.(pool.names[3]) ~ (kgC/m^2)),
     cex.lab=1.25)
points(Forecast[[10]]$Nf[,1],Forecast[[10]]$Nf[,3],cex=1,col="purple",pch=18)
points(No[10,1],No[10,3],cex=3,col=1)
lines(No[10,1]+c(-1,1)*sqrt(R[1,1]),rep(No[10,3],2))
lines(rep(No[10,1],2),No[10,3]+c(-1,1)*sqrt(R[3,3]))

## ensemble adjustment
ne = nrow(Forecast[[10]]$Nf)
sel.a= seq(1,ne,length=10)#sample.int(ne,10)
arrows(Forecast[[10]]$Nf[sel.a,1],Forecast[[10]]$Nf[sel.a,3],
       Analysis[[10]]$Na[sel.a,1],Analysis[[10]]$Na[sel.a,3],length = 0.1,lwd = 0.5)   
legend("bottomright",
       legend=c("Forecast","Analysis","Data"),
       pch=c(1,3,18),col=c("purple","#b2df8a",1),
       cex = 1.25)

######### experiment 5 - one disturb, 2 sites
load("exp5trim.Rdata") ##Generated by TwoSite_SingleDisturb_MultiPool.Rmd
pool.names=c("Leaf","Soil","Wood")
rng = range(CI.Na)
if(rng[1]<1) rng[1] = 0
plot(No[,i],
     ylim = rng,type='n',
     ylab=bquote(.(pool.names[i]) ~ (kgC/m^2)),xlab="time",
     main="Multi-Site, Single-Disturbance")
  ecoforecastR::ciEnvelope(1:ncol(CI.Na[[3]]),CI.Na[[3]][1,],CI.Na[[3]][3,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
  ecoforecastR::ciEnvelope(1:ncol(CI.Na[[6]]),CI.Na[[6]][1,],CI.Na[[6]][3,],col=ecoforecastR::col.alpha("green",0.7))
lines(CI.Na[[3]][2,],col="#b2df8a",lwd=2)
lines(CI.Na[[6]][2,],col="green",lwd=2)
points(No[,3])
points(No[,6],pch=2)
legend("bottomleft",legend=c("Site 1","Site 2","pseudodata"),
       lwd=5,col=c("#b2df8a","green","black"))

### cov plot
ss = floor(seq(1,nrow(Analysis10$Na),length=200)) ## subsample
plot(Analysis10$Na[,1],Analysis10$Na[,3],pch=Analysis10$Ca,col=ecoforecastR::col.alpha("#b2df8a",alpha=1),
     ylim=range(Forecast10$Nf[,3,1]),
     xlim=range(Forecast10$Nf[,1,1]),
     xlab=bquote(.(pool.names[1]) ~ (kgC/m^2)),
     ylab=bquote(.(pool.names[3]) ~ (kgC/m^2)),
     cex.lab=1.25,asp = 1,type='n')
points(Forecast10$Nf[ss,1,1],Forecast10$Nf[ss,3,1],cex=0.5,col="purple",pch=18)
points(Forecast10$Nf[ss,1,2],Forecast10$Nf[ss,3,2],cex=0.5,col="violet",pch=18)
points(Analysis10$Na[ss,1],Analysis10$Na[ss,3],pch=Analysis10$Ca[ss],col=ecoforecastR::col.alpha("#b2df8a",alpha=0.8),cex=0.5)
points(Analysis10$Na[ss,4],Analysis10$Na[ss,6],pch=Analysis10$Ca[ss],col=ecoforecastR::col.alpha("green",alpha=0.8),cex=0.5)
points(No[10,1],No[10,3],cex=3,col=1)
lines(No[10,1]+c(-1,1)*sqrt(R[1,1]),rep(No[10,3],2))
lines(rep(No[10,1],2),No[10,3]+c(-1,1)*sqrt(R[3,3]))
points(No[10,4],No[10,6],cex=3,col=1)
lines(No[10,4]+c(-1,1)*sqrt(R[1,1]),rep(No[10,6],2))
lines(rep(No[10,4],2),No[10,6]+c(-1,1)*sqrt(R[3,3]))

## ensemble adjustment
sel.a= ss[seq(1,length(ss),length=10)]#sample.int(ne,10)
arrows(Forecast10$Nf[sel.a,1,1],Forecast10$Nf[sel.a,3,1],
       Analysis10$Na[sel.a,1],Analysis10$Na[sel.a,3],length = 0.1,lwd = 0.5)
arrows(Forecast10$Nf[sel.a,1,2],Forecast10$Nf[sel.a,3,2],
       Analysis10$Na[sel.a,4],Analysis10$Na[sel.a,6],length = 0.1,lwd = 0.5)
legend("topleft",
       legend=c("Forecast","Analysis","Data"),
       pch=c(1,3,18),col=c("purple","#b2df8a",1),
       cex = 1)
```

## VSEM Calibration

Prior to applying the VSEM to simulate the conifer forest carbon cycle in Oregon the model was calibrated against AGB, leaf C, and NEE data from AmeriFlux site US-ME2.  Best fit parameters are given in Supplemental Table \@ref(tab:parameters). The best fit to the observed data was for AGB, which had a $R^2$ of 0.977, a RMSE of 0.089 $kgC/m^2$ (1.7%), and a bias of -1.1% (-0.059 $kgC/m^2$) (Supplemental figure \@ref(fig:calibration) ). Achieving this fit came at the cost of nontrivial systematic biases in both leaf carbon (0.064 $kgC/m^2$, 13%) and NEE (0.528 $kgC/m^2/year$, 69%). The RMSEs for leaf carbon (0.067 $kgC/m^2$, 13.6%) and NEE (0.612 $kgC/m^2/year$, 80%) were similar to the biases, suggesting that most of the model error was systematic, particularly for leaf carbon.

The dynamic process errors for the leaf, wood, and soil pools, which were approximated as the RMSE of the _change_ in each pool each year, were 0.01, 0.03, and 0.15 $kgC/m^2/yr$. This represents a dynamic error of 2.1%, 0.6%, and 0.7% respectively relative to the size of the pool and a CV of 114% and 17% for leaf and wood relative to the observed annual biomass increment.

Overall, while the inability of the calibration to capture multiple data constraints simultaneously does suggest room for improvement in the underlying model (@Cameron2022), the model performed well for our target variable (AGB) and appears adequate for the job of testing the multinomial model against real AGB data for a range of different disturbance events.

```{r paramTable,echo=FALSE}
# load("fit.RData")
# varName = c(names(theta),"Ql","Qw","Qs")
# varName[c(5,7)] = c("tauL","tauW")
# paramTable = data.frame(varName,fit=format(c(theta,Ql,Qw,Qs),digits=3,scientific=TRUE))
# knitr::kable(paramTable, caption = "VSEM parameter estimates")
```

## Remotely-sensed disturbance in Oregon

** TODO: Dongchen wants examples for other disturbances and to know why the assimilation is so constrained **

```{r oregon, echo=FALSE, fig.asp=1, fig.cap="Filter divergence and disturbance detection for central Oregon test case. Left column is the default configuration while the right column is a reduced observation error experiment (Exp 2). Top row is the assimilation for an example site. Middle row shows the across-site distribution of divergence metrics and how these vary by disturbance magnitude (purple) and disturbance type (symbols). Bottom row shows how the probability of detecting the disturbance varies with disturbance magnitude"}
## summary figure showing didn't work great at default error rate
m = matrix(1:6,nrow=3,byrow = TRUE)
layout(m)

### Row 1: Example time-series ###
site = 188
exp.name = c("P1Q1R1","P1Q1R4")
exp.pretty.name = c("(a) Example site, Original","(c) Example site, Low Obs Error")
pool.names=c("Leaf","Soil","AGB")
i = 3 ## Stem
time = 1985:2017
for(ex in seq_along(exp.name)){
  load(paste0("OR_TS_",site,"_",exp.name[ex],".RData"))
  plot(time,Yi[,i],
       ylim = range(rbind(CI.Na,Yi[,i],CI.D),na.rm=TRUE),
       type='n',
       ylab=bquote(.(pool.names[i]) ~ (kgC/m^2)),xlab="time",
       main=exp.pretty.name[ex])
  ecoforecastR::ciEnvelope(time,CI.Na[1,],CI.Na[5,],col=ecoforecastR::col.alpha('#b2df8a',0.7))
  lines(time,CI.Na[3,],col="#b2df8a",lwd=2)
  points(time,Yi[,i])
  if(ex == 1) {
    legend("bottomleft",legend=c("Assimilation","Data"),
       lwd=5,col=c("#b2df8a","black"),cex=0.7)
  }
}

### Row 2: Divergence ###
load("stats.RData")
load("elist.RData")
disturb.names = c("Intact","Other","Cut","Fire","Pest")
disturb.col = c("#ebebeb",'#b04c00','#1f78b4','#faabaa','#b2df8a')
disturb.col.al <- tapply(disturb.col,1:5,FUN=ecoforecastR::col.alpha,0.7); disturb.col.al[1] = disturb.col[1]
div.pretty.name = c("(b) Divergence, Original","(e) Divergence, Low Obs Error")
div.reg <- list()
div.class <- list()
obs.class.re = obs.class; obs.class.re[obs.class.re ==4] = 3; obs.class.re[obs.class.re ==5] = 4; obs.class.re = obs.class.re + 1
for(i in 1:2){
  ## divergence
  div = (elist[[i]]$divergence[,1] - obs.tlo)/
    (apply(elist[[i]]$divergence[,c(2,6)],1,diff)*0.5)
  div.reg[[i]]    = lm(div~obs.tlo)
  div.class[[i]]    = lm(div~obs.tlo + as.factor(obs.class))
  
  dh = density(na.omit(div))
#  abline(v=c(-1,1),lty=2)
  plot(obs.tlo,div,col=disturb.col.al[obs.class.re],
       xlab="final AGB",ylab="Divergence",
       pch=16, main=div.pretty.name[i])
  abline(h=c(-1,1),lty=2)
  abline(div.reg[[i]],col="purple",lwd=3)
  abline(v=0,lty=2)
  lines(dh$y*10,dh$x,lwd=3)
  if(i == 1) legend("topright",legend=disturb.names,
                  col=disturb.col,pch=16,cex=0.7,
                  text.col=c(1,disturb.col[2:5]))
}

### Row 3: Disturbance magnitude vs P(detection) ###
pred.seq=list()
distabs = obs.pre-obs.dist
pred.seq$distabs = seq(min(distabs),max(distabs),length=500)
detect.pretty.name = c("(c) Probability of detection, Original","(f) Probability of Detection, Low Obs Error")
dist.qb.abs <- list()
for(i in 1:2){
  distrate = distrate = elist[[i]]$distrate
  dist.qb.abs[[i]] = glm(distrate ~ distabs,
                    na.action=na.omit,
                    family=quasibinomial("logit")
  )
  plot(distabs,distrate,col=disturb.col.al[obs.class.re],
       xlab="AGB disturbance magnitude",ylab="P(detect)",
       pch=16, main=detect.pretty.name[i],xlim=c(0,17))
  lines(pred.seq$distabs,predict(dist.qb.abs[[i]],newdata=pred.seq,type="response"),col="purple")
  if(i == 1) legend("topleft",legend=disturb.names,
                  col=disturb.col,pch=16,cex=0.7,
                  text.col=c(1,disturb.col[2:5]))
}
```
In total we assimilated 365 example AGB time series from our central Oregon study region, with 81 coming from undisturbed sites and 78, 88, 92, and 17 coming from clear cuts, fires, forest pests, and other disturbances, respectively. Initial applications of the multinomial filter exhibited high rates of filter divergence, with a coverage of only `r format(stats[[1]]$div.cov*100,digits=3)`% of the observations falling within the Analysis 95% CI at the end of the timeseries. Filter divergence is a known issue for Kalman Filters, not something unique to our multinomial filter, and results from the model becoming falsely overconfident in itself such that it ignores, and diverges from, the data. Figure \@ref(fig:oregon) a demonstates an example of this for a site that experienced a forest fire in 1999, yet the model continues to believe the site is undisturbed. Across sites the magnitude of filter divergence observed was negatively correlated with the amount of biomass at the end of the timeseries (Figure \@ref(fig:oregon) b, p < `r format(anova(div.reg[[1]])$"Pr(>F)"[1],digits=3,scientific=TRUE)`). In other words, sites with low final biomass (i.e., large previous disturbance) showed a larger divergence and the divergence declined as the final biomass increased. Divergence also varied by disturbance type (p < `r format(anova(div.class[[1]])$"Pr(>F)"[2],digits=3,scientific=TRUE)`), with clear cuts having the lowest divergence for a given disturbance size and forest pests being lower than the fires and "other". Despite the issue of filter divergence there was still a positive relationship between disturbance magnitude and the posterior probability of detecting disturbance (Figure \@ref(fig:oregon) c, p < `r format(summary(dist.qb.abs[[1]])$coefficients[2,4],digits=3,scientific=TRUE)`). However, detection was rarely successful for AGB disturbances that removed less than 7.5 $kgC/m^2$ and did not exceed 50% until disturbances were larger than `r bm=coef(dist.qb.abs[[1]]); format(-bm[1]/bm[2],digits=2)` $kgC/m^2$.

The causes of filter divergence are known to be some combination of model overconfidence (e.g., insufficient process error, Q) and high observation error (R) in the data. As described in the Methods we ran additional computational experiments where we varied Q and R (\@ref(tab:QRexp)) to verify that without filter divergence the multinomial filter was able to capture real-world disturbances and to assess what level of variance inflation was required to do so. Figure \@ref(fig:oregon) d-f show the results for Experiment 2, where we experimented with reducing the observation error, R. In this experiment we see that the data assimilation follows the observations closely, with a much tighter interval estimate, and is able to catch the disturbance event (Figure \@ref(fig:oregon) d). We also see much lower incidence of filter divergence across sites, with a posterior coverage at the final timestep of `r format(stats[[2]]$div.cov*100,digits=3)`%, (Figure \@ref(fig:oregon) e). Divergence is no longer significantly affected by disturbance magnitude (p < `r format(summary(div.class[[2]])$coefficients[2,4],digits=3)`) and the only significant effect of disturbance type was a small reduction in divergence for clearcuts (p < `r format(summary(div.class[[2]])$coefficients[3,4],digits=3)`). Most importantly, detection probabilities were strongly related to disturbance magnitude (Figure \@ref(fig:oregon) f), successfully detecting disturbances that removed more than `r bm=coef(dist.qb.abs[[2]]); format(-bm[1]/bm[2],digits=2)` $kgC/m^2$.

Looking across all of our experiments, the coverage of our filter divergence statistic improved as the observation error decreased (Figure \@ref(fig:divExp)a). Increasing process error had little impact at the original observation error, but improved coverage once the observation error was decreased. The threshold disturbance magnitude required to detect disturbances also improved (i.e., became smaller) as the observation error decreased (Figure \@ref(fig:divExp)b) but was insensitive to process error, at least for the values we explored in our computational experiments.
    
```{r divExp,echo=FALSE,fig.cap="Sensitivity of (a) filter divergence coverage, and (b) disturbance detection threshold to variance inflation of the observation error (x-axis) and process error (symbols)",fig.asp=1.5 , fig.width=4.5}
m = matrix(1:2,nrow=2,byrow = TRUE)
layout(m)
## Divergence
div.cov = sapply(stats,"[[","div.cov")
plot(Rmult[Rs],div.cov,col=Qs,pch=Qs,log="x",xlab="Variance Multiplier",ylab="Filter Coverage",main="(a) Filter Coverage")
legend("topright",legend=paste0(Qmult[1:2],"x"),col=1:2,pch=1:2,title="Q")

#div.median = sapply(stats,"[[","div.median")
#plot(Rmult[Rs],div.median,col=Qs,pch=Qs,log="x",xlab="Variance Multiplier",ylab="Median Divergance",main="(b) Filter Divergence")
#legend("topleft",legend=paste0(Qmult[1:2],"x"),col=1:2,pch=1:2)

## Detection probability
for(i in 3:6){
  distrate = distrate = elist[[i]]$distrate
  dist.qb.abs[[i]] = glm(distrate ~ distabs,
                    na.action=na.omit,
                    family=quasibinomial("logit")
  )
}
thresh = sapply(dist.qb.abs,function(x){bm=coef(x); -bm[1]/bm[2]})
plot(Rmult[Rs],thresh,col=Qs,pch=Qs,log="x",xlab="Variance Multiplier",ylab=expression("Detection Threshold" ~ (kgC/m^2)),main="(b) Disturbance Detection Threshold")
legend("topleft",legend=paste0(Qmult[1:2],"x"),col=1:2,pch=1:2)
```

<!-- Future direction: rerun using disturbance data product as priors on disturbance probability -->
